CRIANDO HTML 

VIEWS  ---- 

PARA UTILIZAR BASTA IR NO CONTROLLER 
E RETORNAR A FUNCAO 
RERTURN VIEW();
BUSCA UM ARQWUIVO DE VISUALIZACAO E DESSA VIEW ELA MONTA UMA RESPOSTA 
FUNCAO COMPACT ELA PEGA O ARGUMENTO QUE PASSOU COMO INSTRING E PEGA A VARIAVEL COM O NOME E MONTAR UM ARRAY

RETURN VIEW('LISTASERIES', COMPACT('SERIES'));
AO INVES DE 

 return view('ListarSeries', [
        'series' => $series
      ]);
     

## CONHECENDO O BLADE

LARAVEL DOCUMENTACTION
COMPONENTE QUE AJUDA A GENTE A CRIAR VIEWS, FACILITA ESCREVER OS CODIGOS NA BIOS, VANTAGENS REMOVER TAGS DO PHP <?FOREACH> SUBSTITUINDO POR @FOREACH, ESSA SINTAXE FAZ EXATAMENTO O ECHO  {{}}

LAYOUT COM BLADE
COMPONENTES DE BLADE DENTRO DE VIEWS
{{SLOT}}
<X-LAYOUT TITLE=''>
EVITA AMBIUIDADE HTML 
PASSANDO UM JS COM JS::FROM, ACESSAR A VARIAVEL NO VIEW

## CREATE 
    ADCIONAR DENTRO DA VIEW INDEX UM LINK PARA ACESSAR
    <a href="/series/criar">Adicionar</a>

    CRIAR UMA NOVA VIEW CREATE.BLADE USAR O <X-NOME>

    PASSAR A ROTA REFERENCIANDO O METHOD CREATE DO CONTROLE NA CLASS
    "SERIESCONTROLE::CLASSS , 'CREATE'"


## DEPENDENCIAS DE FRONT END 

## CONFIGURACOES 

\\ CONFIG 
CONFIGURA OS BANCOS AONDE PODE COLOCAR A APLCIACAO BANCO VOCE ESTA COM A APLICACAO, SELITE, MYSQL ETC 

ENV - > DEFINE   O BANCO QUE ESTA APLICADO O CODIGO 

## VARIAVEIS DE HAMBIENTE 

## DATABASE 

\\ MIGRATIONS 
-- CRIACAO DE TABELAS PONTO DE ALTERACAO NO BANCO DE DADOS 
- PARA CRIAR UMA MIGRATE E SO PASSAR O ARTISAN MAKE:MIGRATION 

- PARA ENVIAR A ATUALIZACAO PARA O BANCO E OS RODAR 
ARTISAN MIGRATE 

REVERTER MIGRATE:ROLLBACK 

## DB FACADE

- FORMAS DE INSERIR DADOS NO BANCO 
CLASSE CHEIA DE METODOS  ESTATICOS 
DB::INSERT()
PARA CONSEGUIR USAR TEM QUE PASSAR O USE DB;

- PARA MOSTRAR NA TELA AS ALTERACOES NO CONTROLLER::INDEX TEM QUE PASSAR 
DB::SELECT  

E NO VIEWS CREATE PASSAR $SERIES->NOME

## REDIRECIONAR O USUARIO 
RETURN REDIRECT('/SERIES)

## ELOQUENT ORM 
PHP ARTISAN MAKE:MODEL 

SE O NOME DA TABELA FOR DIFERENTE DA CLASSE CRIADA PODE-SE USAR 
PROTECT $TABLE = 'NOME'

## CRIANDO SERIES

\\ METODO STORE 

\\ SERIE::CREATE($REQUEST->ALL())

\\ SEMPRE QUE CRIAR UMA ALL, TEM QUE SER INFORMADO NA MODEL UMA QUAIS CAMPOS PODEM SER ATRIBUIDOS COM A FILABLE
\\ PROTECT $FILLABLE = [] > CAMPO DELA E UM ARRAY

## AGRUPANDO ACTIONS

EXISTE UM GUPO DE CONTROLLER 
\\ ROUTE::CONTROLLER > INOFRMAR A CLASSE QUE O GRUPO PERTENCE 
DEPOIS PODE PASSAR UMA FUNCTIO -GROUP E VINCULAR TODAS AS ROTAS COM A URI E A ACTION SOMENTE 

## OUTRO MODO 

SERIA PELO RESOURCE, TEM QUE SER USADO COM OS DIRETORIOS EM INGLES

## NOMEANDO ROTAS 

SEM ALTERAR NA VIEWS EXISTE ROTAS NOMEADAS
COM O METODO -> NAME QUE E PASSADA NA ROUTES 

E CHAMADA NA VIEWS COM {{ROUTE('SERIES.CREATE)}} NOME DA ROTA

## DEFININDO NOMES EU CONSIGO USAR A ROTA RESOURCE CHAMANDO APENAS O METODO SERIES 

## DELETE

\\ SESSION E FLASH MESSAGES

# DENTRO DO DESTROY 

$REQUEST->SESSION()->PUT('MENSAGEM.SUCESSO', 'SERIE REMOVIDA COM SUCESSO');
PODE TAMBEM USAR AO INVES DO PUT O METHODO FLASH 
FAZENDO COM QUE A MENSAGEM AO CARREGAR A VIEW INDEX SEJA ESQUECIDA AUTOMATICAMENTE QUANDO ATUALIZAR A PAGINA


# DENTRO DO CONTROLLER INDEX TEM QUE SER PASSADO O VALOR DA MENSAGEM 
$MENSAGEMSUCESSO = $REQUEST->SESSION()->GET('MENSAGEM.SUCESSO);

# O METODO FORGET FAZ COM QUE DEPOIS DE SER DELETADA A SERIE AO ATUALIZAR A INDEX A MENSAGEM SAI ISSO USANDO O METODO PUT, POIS O FLASH NAO PRECISA DO FORGET
$REQUEST->SESSION()->FORGET('MENSAGEM.SUCESSO');
 ASSIM ELE RETORNARA NA INDEX VIEW A MENSAGEM DEPOIS DE EXECUTAR O DELETE.

# INDEX VIEW 
TEM DE SER PASSSADO UMA DIV COM O PARAMETO DA MENSAGEM PODE SER PASSADO DENTRO DE UMA CONDICAO PARA APARECER APENAS QUANDO O METODO FOR CHAMADO 

 @ISSET($MENSAGEMSUCESSO)
 <DIV >
 {{$MENSAGEMSUCESSO}}
 </DIV>
 @ENDISSET

 # ADICIONAR MENSAGEM NO STORE 
 # SESSION
 SESSION('MENSAGEM.SUCESSO' , 'SERIE ADICIONADA COM SUCESSO')

 # OU COM FLASH MESSAGES

 $REQUEST->SESSION()->FLASH('MENSAGEM.SUCESSO', 'SERIE ADICIONADA COM SUCESSO');

 # MAIS  DADOS NA REQUISICAO 

PASSANDO O NOME DA VARIAVEL NO STORE 

 ADICIONAR O NOME DA VAIAVEL NA REQUISICAO, $REQUEST->SESSION()->FLASH('...{$SERIE->NOME}')

# JA NO METODO DESTROY 
ELE NAO RETORNA UMA STRING E SIM UM INTEIRO NO MODO $REQUEST QUERY

SE EU QUERO RECUP O NOME TEM QUE SER FEITO O SELECT 

INFORMANDO O PARAMETO NA PUBLIC  FUNCTION DESTROY( MODEL'SERIE' VAR $SERIES, REQUEST $REQUEST)
DESSA FORMA ELE FAZ UM SELECT NO BANCO E RETORNA O NOME DA SERIE
SENDO ASSIM PODE PASSAR DIRETO DA INSTANCIA O METODO DELETE 
# $SEIRIES->DELETE(); 
DEPOIS E SO COLOCAR O PARAMETO NO CODIGO PARA REOTRNA O NOME

# REDIRECIONAMENTOS

SEJA NO MEOTDO REDIRECT()->ROUTE() OU TO_ROUTE()

TEM UM METODO CHAMADO 
TO_ROUTE()->WITH();
FAZ O REDIRECIONAMENTO COM UMA FLASH MENSAGEM, NAO PRECISANDO DE USAR O REQUEST NO DESTROY;

## VALIDACOES 

\\ REQUEST -> CRIACAO E EDICAO 
$REQUEST->VALIDATE([
  'NOME' => ['REQUIRED' , 'MIN:3']
]) 
SE NAO FOR SATISFEITA ELA REDIRECIONA O USUARIO PARA A ROTA ANTERIOR
TEM QUE SER CRIADA NE UM ARRAY DE REGRAS 
PASSANDO CAMPOS OBRIGATORIOS, SE PASSAR O NOME VAZIO ELE RETORNA 

## EXIBINDO ERROS 

\\ O LAVAREL RETORNA UM JSON COM MENSAGEMS DE ERROS
POR MEIO DE UMA VARIAVEL QUE CHAMA $ERROS JA EXISTENTE NO LARAVEL

ELA PODE SER PASSSADA NA VIEW 

## DENTRO DA VIEW EU POSSO PASSAR A FUNCAO :NOM"OLD()"
SE EU QUISER PREENCHER O CAMPO,PEGA DA FLASH SESSIONS A REQUISICAO ANTERIOR
DENTRO DO FORM AO INVES DE VERIFICAR SE O VALOR DO CAMPO EXISTE, PASSO A CONDICAO SE O METODO UPDATE EXISTE 
E NO EDIT AO INVES DE SO PASSAR O NOME EU INFORMO QUE O UPDATE E IGUAL A TRUE 
POIS AI O CODIGO NAO PASSA O PARAMETRO PUT ESCONDIDO DO METODO


# CRIANDO O PROPRIO REQUEST 

USANDO O ARTISAN 
MAKE::REQUEST NOMEREQUEST 

COLOCO AS ERGRAS DE VALIDACOES DENTRO DE 
FUNCTION RULES() {
  RETURN [ 
    'NOME' => ['REQUIRED', 'MIN3'], 

  ]
}

\\ TAMBEM POSSO CRIAR UMA PUBLIC FUNCTION MESSAGES ()
PASSANDO A MENSAGEM QUE EU QUERO QUE RETORNE PARA O USUARIO 
FUNCTION MESSAGES() {
  RETURN [
      'NOME.REQUIRED' => 'MENSAGEM'
  ]
}

## TEMPORADAS E EPSODIOS 

ANTES PRECISA CRIAR AS MODEL 
METODO DE RELACIONAMENTO ENTRE MODELS 
DEVE SER CRIADO UM METODO DENTRO DA MODEL SEASON 
EX DE TEMPORADAS 
PUBLIC FUNCTION TEMPORADAS() {
  RETURN $THIS->HASMANY(SEASON::CLASS); 
  RELACIONAMENTO DO TIPO UM PARA MUITOS, UMA SERIE POSSUI MUITAS TEMPORADAS 
}

OU AO INVERSO POSSO DIZER QUE A TEMPORADA PERTENCE A UMA DETERMINADA SERIE

PUBLIC FUNCTION SERIES() {
  RETURN $THIS->BELONGTO(SERIE::CLASS)
}

POSSO DIZER QUE UMA TEMPORADA TEM VARIOS EPSODIOS 

PUBLIC FUNCTION EPISODES(){
  RETURN $THIS->HASMANY(EPISODE::CLASS)
}

DENTRO DA MODEL EPSODE POSSO MONITORAR A SEASON
PUBLIC FUNCTION SEASON() {
    RETURN $THIS->BELONGDTO(SEASON::CLASS)
}

## MODELS

SCOPOS GLOBAIIS E LOCAIS 

POSSO CRIAR UM SCOPO DE BUSCA ORDENAR
METODO BOOTED 

DENTRO DA MODEL SERIE
PROTECTED STATIC FUNCTION BOOTED() 
{
  SELF::ADDGLOBALSCOPE('ORDERED', FUNCTION(BUILDER $QUERYBUILDER){
    $QUERYBUILDER->ORDERBY('NOME');
  });
}

LAISEN LOLDEN 
MEOTDO WITH 

## RECRIANDO O BANCO 

PARA ALTERAR INFORMACOES NO BANCO TEM QUE RODAR 
PHP ARTISAN MIGRATE:FRESH 

ELE LIMPA AS TABELAS E INCLUI DE NOVO SE CASO HOUVER ALGUMA MODIFICACAO JA ATUALIZA



## API REST UTILIZANDO JWT 

